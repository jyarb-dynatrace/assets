{
  "id": "bbfed115-81c2-49a8-92b0-141fe970f7fd",
  "title": "Workflow Essentials - Data Generator",
  "tasks": {
    "config": {
      "name": "config",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// optional import of sdk modules\nimport { execution } from '@dynatrace-sdk/automation-utils';\n\nexport default async function ({ execution_id }) {\n\n\n  // General configuration\n  \n  // Name of the event.provider field that will be used. Events in the future will be stored in a provider\n  // with \".temp\" appended to the end.\n  const EVENT_PROVIDER = \"workflow.essentials.withdraw-processing\";\n  \n  // Steps you wish the process to have, the first field is the \"pretty name\", the\n  // second is what the field name in the BizEvent will be, and the numbers after it are:\n  // First number: \"Drop off\" percentage.\n  // Second number: Minimum time (in hours) for the step to take\n  // Third number: Maximum time (in hours) for the step to take\n  // The last 2 numbers are ignored for the first step, so just set them to 0.\n  const PROCESS_STEPS = [\n    [\"Withdraw Submitted\",\"01.withdraw.submitted\", 0,0,0],\n    [\"Balance Verified\",\"02.balance.verified\", 0.1,0.2,0.4],\n    [\"Notify Bank\",\"03.notify.bank\", 0.1,0.1,0.2],\n    [\"Bank Acknowledge\",\"04.bank.acknowledge\", 1,0.5,2],\n    [\"Transfer Funds\",\"05.transfer.funds\", 3,0.2,24],\n    [\"Funds Received\",\"06.funds.received\", 2,0.2,24],\n    [\"Notify Regulatory Board\",\"07.notify.regulatory.board\",0,0.2,0.5],\n    [\"Regulatory Board Acknowledge\",\"08.regulatory.board.acknowledge\",0,0.1,1]\n  ];\n  \n  // Locations you wish to be attached to the users, the number after it\n  // is the percentage that will have that location - they must add up to 100.\n  const LOCATIONS_WITH_PERCENTAGE = [\n    ['USA', 25],\n    ['UK', 20],\n    ['Brazil', 12],\n    ['France', 10],\n    ['Mexico', 8],\n    ['Australia', 7],\n    ['Dubai', 6],\n    ['India', 5],\n    ['Italy', 4],\n    ['Singapore', 3],\n  ];\n  \n  // The name of the different \"segments\" of users you wish to have, this will be\n  // the field name of the field on the BizEvent.\n  const SEGMENT_NAME = \"account-type\";\n  \n  // Different segments you wish the users to have (example here is payment types), the\n  // number after it is the percentage that will have that segment - they must add up to 100.\n  const SEGMENTS = [\n    ['none', 40],\n    ['silver', 20],\n    ['gold', 16],\n    ['platinum', 18],\n    ['diamond', 6],\n  ];\n  \n  // Hosts from your environment that you can randomly attribute to BizEvents, you need to\n  // use the Dynatrace identifier and make sure the percentages add up to 100.\n  const HOST_ENTITY = [\n    ['HOST-6B29B384CBF5C6E4', 100]\n  ];\n  \n  // Name of the correlation ID that will be added to each BizEvent, this will be the name\n  // of the field that you see in the BizEvent.\n  const CORRELATION_ID = \"trxn.withdraw-processing.id\";\n  \n  // Different errors that you want to attach to a certain step:\n  // - First field is the name of the error which will be appeneded to the step name.\n  // - Second field is the (zero indexed) step this error will happen on.\n  // - Third field is the percentage of time this error will happen. (which is only used in the follow-uper)\n  // For this first batch of data, anything in the last 2 hours will be a guaranteed error.\n  const ERRORS_WITH_PERCENTAGE = [\n    ['trxn.withdraw-processing.error', 4, 3],\n  ];\n  \n  // Distribute the load by the time of day, by default the \"peak\" is around midday\n  // - First field is the hour of the day, so 0 being midnight.\n  // - Second field is the percentage distribution.\n  // As usual, all percentages must add up to 100.\n  const TIMES_OF_DAY = [\n    [0,1],\n    [1,1],\n    [2,1],\n    [3,1],\n    [4,2],\n    [5,3],\n    [6,3],\n    [7,4],\n    [8,6],\n    [9,9],\n    [10,9],\n    [11,10],\n    [12,10],\n    [13,9],\n    [14,9],\n    [15,6],\n    [16,4],\n    [17,3],\n    [18,3],\n    [19,2],\n    [20,1],\n    [21,1],\n    [22,1],\n    [23,1]\n  ]\n \n  const VARIABLES = {\n    \"EVENT_PROVIDER\": EVENT_PROVIDER,\n    \"PROCESS_STEPS\": PROCESS_STEPS,\n    \"LOCATIONS_WITH_PERCENTAGE\": LOCATIONS_WITH_PERCENTAGE,\n    \"SEGMENT_NAME\": SEGMENT_NAME, \n    \"SEGMENTS\": SEGMENTS,\n    \"HOST_ENTITY\": HOST_ENTITY,\n    \"CORRELATION_ID\": CORRELATION_ID,\n    \"ERRORS_WITH_PERCENTAGE\": ERRORS_WITH_PERCENTAGE,\n    \"TIMES_OF_DAY\": TIMES_OF_DAY\n  }\n  \n  return VARIABLES;\n}"
      },
      "position": {
        "x": 0,
        "y": 1
      },
      "predecessors": []
    },
    "generate_new_data": {
      "name": "generate_new_data",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// Numbers for reference\nconst MS_IN_S = 1000;\nconst MS_IN_MINUTE = 60 * MS_IN_S;\nconst MS_IN_HOUR = 60 * MS_IN_MINUTE;\nconst MS_IN_DAY = 24 * MS_IN_HOUR;\n\nexport default async function ({ execution_id }) {\n\n  // Variable declaration\n  const configGet = await fetch(`/platform/automation/v1/executions/${execution_id}/tasks/config/result`);\n  const configBody = await configGet.json();\n    \n  const EVENT_PROVIDER = configBody['EVENT_PROVIDER'];\n  const PROCESS_STEPS = configBody['PROCESS_STEPS'];\n  const LOCATIONS_WITH_PERCENTAGE = configBody['LOCATIONS_WITH_PERCENTAGE'];\n  const SEGMENT_NAME = configBody['SEGMENT_NAME']; \n  const SEGMENTS = configBody['SEGMENTS'];\n  const HOST_ENTITY = configBody['HOST_ENTITY'];\n  const CORRELATION_ID = configBody['CORRELATION_ID'];\n  const ERRORS_WITH_PERCENTAGE = configBody['ERRORS_WITH_PERCENTAGE'];\n  const TIMES_OF_DAY = configBody['TIMES_OF_DAY']; \n\n  // Function for getting random values with probabilities (which is why we have all the numbers\n  // stacked up in the arrays above)\n  const getRandomWithProbability = (array) => {\n    const filled = array.flatMap(([value, prob]) => Array.from({ length: prob }).fill(value));\n    const random = Math.floor(Math.random() * filled.length);\n    return filled[random];\n  }\n  \n  // Function to check if we need to throw an error for a given event\n  const checkIfError = (step) => {\n    var isError = false;\n    var errorName = \"\";\n    ERRORS_WITH_PERCENTAGE.forEach((item) => {\n      if(step == item[1] && getRandomInt([1,100]) < item[2]) {\n        isError = true;\n        errorName = item[0];\n      }\n    })\n  \n    const errorResult = {\n      \"isError\": isError,\n      \"errorName\": errorName\n    }\n    \n    return errorResult;\n  }\n  \n  //Function for getting a random value from an array\n  const getRandomFromArray = (array) => array[Math.floor(Math.random() * array.length)];\n  \n  // Function for getting a random number between 2 integers\n  // The maximum is exclusive and the minimum is inclusive\n  const getRandomInt = ([min, max]) => Math.floor(Math.random() * (max - min) + min);\n\n  \n  \n  const now = new Date();\n  const nowMinusTwentyFourH = now - (MS_IN_DAY);\n  const nowMinusFiveM = now - (MS_IN_MINUTE * 5);\n  const nowMinusTwoH = now - (MS_IN_HOUR * 2);\n  \n  let flows = [];\n\n  // Run through and create up to 2 events every 5 minutes - this should produce a similar\n  // load profile to carry on what the \"data generator\" did\n  for(let i=0; i<5; i++) {\n\n    // Based on the time of day, choose if an event is going to get generated\n    var rollRandom = getRandomInt([0, 100]);\n    var makeNewEvent = TIMES_OF_DAY[now.getHours()][1] * 10;\n\n   if(rollRandom < makeNewEvent) {\n\n    console.log(\"Making event start\");\n     \n    // Set the high level attributes which will apply across all events\n    // Start time is set here for the first event, then all others are relative to this\n    var LOCATION = getRandomWithProbability(LOCATIONS_WITH_PERCENTAGE);\n    var UID = crypto.randomUUID();\n    var SEGMENT = getRandomWithProbability(SEGMENTS);\n    var HOST = getRandomWithProbability(HOST_ENTITY);\n    var START_TIME = new Date(nowMinusTwentyFourH + (getRandomInt([1, now.getTime() - nowMinusTwentyFourH])));\n    START_TIME.setHours(getRandomWithProbability(TIMES_OF_DAY));\n\n    // If the start time has a chance of being slightly later this hour, then\n    // wind it back 24 hours\n    if(START_TIME.getHours() > now.getHours()) {\n      START_TIME = new Date(START_TIME - MS_IN_DAY);\n    }\n\n     // Keep going until the start time falls in the desired range\n    while (START_TIME > now || START_TIME < nowMinusFiveM) {\n       START_TIME = new Date(nowMinusTwentyFourH + (getRandomInt([1, now - nowMinusTwentyFourH]))); \n\n       if(START_TIME.getHours() > now.getHours()) {\n         START_TIME = START_TIME - MS_IN_DAY;\n       }      \n    }\n    \n    var stop = false;\n\n    // Loop through every step that you've defined, checks will be made for:\n    // 1. Do we need to \"drop off\" based on the probability you defined\n    // 2. Do we need to \"throw an error\" based on the errors defined above and stop\n    PROCESS_STEPS.forEach((item, index) => {\n\n      // If it's the first step, run this loop\n      if(index == 0) {\n        var event = {\n          \"event.provider\": EVENT_PROVIDER,\n          \"event.type\": item[1],\n          [CORRELATION_ID]: UID,\n          [SEGMENT_NAME]: SEGMENT,\n          \"dt.entity.host\": HOST,\n          \"timestamp\": START_TIME,\n          \"booking.value\": getRandomInt([505,2430])\n        }\n        stop = false;\n      }\n\n      // If it's the second step, run this loop\n      // Where an event is in the future it will be put under the same event.provider with\n      // \".temp\" added to the end and be picked up by the \"follow-uper\" when the right time comes        \n      else if (index > 0 && getRandomInt([0, 100]) > PROCESS_STEPS[index][2] && stop == false) {\n        \n        START_TIME = new Date(START_TIME.getTime() + getRandomInt([PROCESS_STEPS[index][3] * MS_IN_HOUR, PROCESS_STEPS[index][4] * MS_IN_HOUR]));\n\n        if(START_TIME < now) {\n          var eventType = item[1];\n          stop = false;\n\n          var errorState = checkIfError(index);\n          \n          if(START_TIME > nowMinusTwoH && errorState[\"isError\"] == true) {\n            eventType = item[1] + \".\" + errorState[\"errorName\"];\n            stop = true;\n            \n          }\n          else {\n            stop = false;\n          }\n          var event = {\n            \"event.provider\": EVENT_PROVIDER,\n            \"event.type\": eventType,\n            [CORRELATION_ID]: UID,\n            [SEGMENT_NAME]: SEGMENT,\n            \"dt.entity.host\": HOST,\n            \"timestamp\": START_TIME\n          }\n          \n       }   \n       else {\n         var errorState = checkIfError(index);\n         if(errorState[\"isError\"] == true) {\n           eventType = item[1] + '.' + errorState[\"errorName\"];\n           stop = true;\n         }\n         else {\n           eventType = item[1];\n           stop = false;\n         }\n         \n         var futureEvent = {\n          \"event.provider\": EVENT_PROVIDER + \".temp\",\n          \"event.type\": eventType,\n          [CORRELATION_ID]: UID,\n          [SEGMENT_NAME]: SEGMENT,\n          \"dt.entity.host\": HOST,\n          \"future.timestamp\": START_TIME,\n          \"timestamp\": now.toISOString()\n         }\n         flows.push(futureEvent);\n         }\n       \n      }\n\n      else {\n        stop = true;        \n      }\n      \n      if(event != undefined){\n        flows.push(event);\n      }\n    });\n\n   }\n    \n  }\n\n  console.log(flows);\n  \n  //Send all the events into the BizEvents API\n  const result = await fetch('/platform/classic/environment-api/v2/bizevents/ingest', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(flows),\n  });\n\n  console.log(result);\n  \n  return flows;\n}\n"
      },
      "active": true,
      "position": {
        "x": 0,
        "y": 2
      },
      "predecessors": [
        "config"
      ],
      "conditions": {
        "states": {
          "config": "OK"
        }
      }
    },
    "check_if_data_exists": {
      "name": "check_if_data_exists",
      "action": "dynatrace.automations:execute-dql-query",
      "description": "Executes DQL query",
      "input": {
        "query": "fetch bizevents\n| filter event.provider == \"{{result('config').EVENT_PROVIDER}}\""
      },
      "position": {
        "x": -1,
        "y": 2
      },
      "predecessors": [
        "config"
      ],
      "conditions": {
        "states": {
          "config": "OK"
        }
      }
    },
    "generate_historical_data": {
      "name": "generate_historical_data",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "import { execution } from '@dynatrace-sdk/automation-utils';\n\nexport default async function ({ execution_id }) {\n\n  // Variable declaration\n  const configGet = await fetch(`/platform/automation/v1/executions/${execution_id}/tasks/config/result`);\n  const configBody = await configGet.json();\n    \n  const EVENT_PROVIDER = configBody['EVENT_PROVIDER'];\n  const PROCESS_STEPS = configBody['PROCESS_STEPS'];\n  const LOCATIONS_WITH_PERCENTAGE = configBody['LOCATIONS_WITH_PERCENTAGE'];\n  const SEGMENT_NAME = configBody['SEGMENT_NAME']; \n  const SEGMENTS = configBody['SEGMENTS'];\n  const HOST_ENTITY = configBody['HOST_ENTITY'];\n  const CORRELATION_ID = configBody['CORRELATION_ID'];\n  const ERRORS_WITH_PERCENTAGE = configBody['ERRORS_WITH_PERCENTAGE'];\n  const TIMES_OF_DAY = configBody['TIMES_OF_DAY']; \n\n  // Check if data exists already - if it does, don't run this again\n  const historyGet = await fetch(`/platform/automation/v1/executions/${execution_id}/tasks/check_if_data_exists/result`);\n  const historyBody = await historyGet.json();  \n  var historyCheck = true;\n  \n  if(historyBody.records.length == 0 || historyBody.records.length == undefined) {\n    historyCheck = false;\n  }\n  else {\n    historyCheck = true;\n  }\n\n  // Override if needed, set this to \"false\" if you need to get more historical data\n  // for any reason\n  // historyCheck = false;\n  \n  // Numbers for reference\n  const MS_IN_S = 1000;\n  const MS_IN_MINUTE = 60 * MS_IN_S;\n  const MS_IN_HOUR = 60 * MS_IN_MINUTE;\n  const MS_IN_DAY = 24 * MS_IN_HOUR;\n  \n  // Function for getting random values with probabilities (which is why we have all the numbers\n  // stacked up in the arrays above)\n  const getRandomWithProbability = (array) => {\n    const filled = array.flatMap(([value, prob]) => Array.from({ length: prob }).fill(value));\n    const random = Math.floor(Math.random() * filled.length);\n    return filled[random];\n  }\n  \n  // Function to check if we need to throw an error for a given event\n  const checkIfError = (step) => {\n    var isError = false;\n    var errorName = \"\";\n    ERRORS_WITH_PERCENTAGE.forEach((item) => {\n      if(step == item[1]) {\n        isError = true;\n        errorName = item[0];\n      }\n    })\n  \n    const errorResult = {\n      \"isError\": isError,\n      \"errorName\": errorName\n    }\n    \n    return errorResult;\n  }\n  \n  //Function for getting a random value from an array\n  const getRandomFromArray = (array) => array[Math.floor(Math.random() * array.length)];\n  \n  // Function for getting a random number between 2 integers\n  // The maximum is exclusive and the minimum is inclusive\n  const getRandomInt = ([min, max]) => Math.floor(Math.random() * (max - min) + min);\n\n\n\n\n  const now = new Date();\n  const nowMinusTwentyFourH = now - (MS_IN_DAY);\n  const nowMinusTwoH = now - (MS_IN_HOUR * 2);\n\n  let flows = [];\n\n  // Run through and create 500 events over the last 24 hours\n  // If you alter this, make sure to alter the \"follow-uper\"\n  if(historyCheck == false) {\n    \n      for(let i=0; i<500; i++) {\n  \n      // Set the high level attributes which will apply across all events\n      // Start time is set here for the first event, then all others are relative to this\n      var LOCATION = getRandomWithProbability(LOCATIONS_WITH_PERCENTAGE);\n      var UID = crypto.randomUUID();\n      var SEGMENT = getRandomWithProbability(SEGMENTS);\n      var HOST = getRandomWithProbability(HOST_ENTITY);\n      var START_TIME = new Date(nowMinusTwentyFourH + (getRandomInt([1, now.getTime() - nowMinusTwentyFourH])));\n      START_TIME.setHours(getRandomWithProbability(TIMES_OF_DAY));\n  \n      // If the start time has a chance of being slightly later this hour, then\n      // wind is back 24 hours\n      if(START_TIME.getHours() > now.getHours()) {\n        START_TIME = new Date(START_TIME - MS_IN_DAY);\n      }\n  \n      // Keep going until the start time falls in the desired range\n      while (START_TIME > now || START_TIME < nowMinusTwentyFourH) {\n         START_TIME = new Date(nowMinusTwentyFourH + (getRandomInt([1, now - nowMinusTwentyFourH]))); \n  \n         if(START_TIME.getHours() > now.getHours()) {\n           START_TIME = START_TIME - MS_IN_DAY;\n         }      \n      }\n      \n      var stop = false;\n  \n      // Loop through every step that you've defined, checks will be made for:\n      // 1. Do we need to \"drop off\" based on the probability you defined\n      // 2. Do we need to \"throw an error\" based on the errors defined above and stop\n      PROCESS_STEPS.forEach((item, index) => {\n  \n        // If it's the first step, run this loop\n        if(index == 0) {\n          var event = {\n            \"event.provider\": EVENT_PROVIDER,\n            \"event.type\": item[1],\n            [CORRELATION_ID]: UID,\n            [SEGMENT_NAME]: SEGMENT,\n            \"dt.entity.host\": HOST,\n            \"timestamp\": START_TIME,\n            \"booking.value\": getRandomInt([505,2430])\n          }\n          stop = false;\n        }\n  \n        // If it's the second step, run this loop\n        // Where an event is in the future it will be put under the same event.provider with\n        // \".temp\" added to the end and be picked up by the \"follow-uper\" when the right time comes\n        else if (index > 0 && getRandomInt([0, 100]) > PROCESS_STEPS[index][2] && stop == false) {\n          \n          START_TIME = new Date(START_TIME.getTime() + getRandomInt([PROCESS_STEPS[index][3] * MS_IN_HOUR, PROCESS_STEPS[index][4] * MS_IN_HOUR]));\n  \n          if(START_TIME < now) {\n            var eventType = item[1];\n            stop = false;\n            \n            if(START_TIME > nowMinusTwoH && checkIfError(index)[\"isError\"] == true) {\n              eventType = item[1] + \".\" + checkIfError(index)[\"errorName\"];\n              stop = true;\n            }\n            else {\n              stop = false;\n            }\n            var event = {\n              \"event.provider\": EVENT_PROVIDER,\n              \"event.type\": eventType,\n              [CORRELATION_ID]: UID,\n              [SEGMENT_NAME]: SEGMENT,\n              \"dt.entity.host\": HOST,\n              \"timestamp\": START_TIME\n            }\n            \n         }   \n         else {\n           var futureEvent = {\n            \"event.provider\": EVENT_PROVIDER + \".temp\",\n            \"event.type\": item[1],\n            [CORRELATION_ID]: UID,\n            [SEGMENT_NAME]: SEGMENT,\n            \"dt.entity.host\": HOST,\n            \"future.timestamp\": START_TIME,\n            \"timestamp\": now.toISOString()\n           }\n  \n           flows.push(futureEvent);\n           }\n         \n        }\n  \n        else {\n          stop = true;        \n        }\n        \n        if(event != undefined){\n          flows.push(event);\n        }\n      });\n      \n    }\n    //Send all the events into the BizEvents API\n    const result = await fetch('/platform/classic/environment-api/v2/bizevents/ingest', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(flows),\n    });\n  \n    console.log(result);\n  }\n\n\n  return flows.length;\n}\n"
      },
      "position": {
        "x": -1,
        "y": 3
      },
      "predecessors": [
        "check_if_data_exists"
      ],
      "conditions": {
        "states": {
          "check_if_data_exists": "OK"
        }
      }
    },
    "process_temporary_events": {
      "name": "process_temporary_events",
      "action": "dynatrace.automations:run-javascript",
      "description": "Build a custom task running js Code",
      "input": {
        "script": "// Import of required SDK modules\nimport { execution } from '@dynatrace-sdk/automation-utils';\nimport { queryExecutionClient } from '@dynatrace-sdk/client-query';\n\n// Numbers for reference\nconst MS_IN_S = 1000;\nconst MS_IN_MINUTE = 60 * MS_IN_S;\nconst MS_IN_HOUR = 60 * MS_IN_MINUTE;\nconst MS_IN_DAY = 24 * MS_IN_HOUR;\n\nexport default async function ({ execution_id }) {\n\n  // Variable declaration\n  const configGet = await fetch(`/platform/automation/v1/executions/${execution_id}/tasks/config/result`);\n  const configBody = await configGet.json();\n    \n  const EVENT_PROVIDER = configBody['EVENT_PROVIDER'];\n  const PROCESS_STEPS = configBody['PROCESS_STEPS'];\n  const LOCATIONS_WITH_PERCENTAGE = configBody['LOCATIONS_WITH_PERCENTAGE'];\n  const SEGMENT_NAME = configBody['SEGMENT_NAME']; \n  const SEGMENTS = configBody['SEGMENTS'];\n  const HOST_ENTITY = configBody['HOST_ENTITY'];\n  const CORRELATION_ID = configBody['CORRELATION_ID'];\n  const ERRORS_WITH_PERCENTAGE = configBody['ERRORS_WITH_PERCENTAGE'];\n  const TIMES_OF_DAY = configBody['TIMES_OF_DAY']; \n  \n  const ex = await execution(execution_id);\n\n  // Get the details about what the time is now, we'll use this to calculate\n  // the sliding window that we need to create\n  const now = new Date();\n  const currentS = now.getSeconds();\n  const currentMs = now.getMilliseconds();\n\n  // Create a start timestamp which is 6 minutes ago, and a finish timestamp which is\n  // 1 minute ago (shifted to take off extra seconds/milliseconds)\n  const start = now - (currentS * MS_IN_S) - currentMs - (360 * MS_IN_S);\n  const finish = now - (currentS * MS_IN_S) - currentMs - (60 * MS_IN_S);\n\n  // Query to check in this sliding window for events which need to be processed\n  // into \"permanent\" from the \".temp\" provider\n  var query = 'fetch bizevents, from:-30d | filter event.provider == \"' + EVENT_PROVIDER + '.temp\" | filter toTimestamp(future.timestamp) > toTimestamp(' + start * 1000000 + ') AND toTimestamp(future.timestamp) < toTimestamp(' + finish * 1000000 + ')';\n\n  console.log(query);\n  \n  // Execute the query and get the results back\n  const queryTempRecords = await queryExecutionClient.queryExecute({ body: { query, requestTimeoutMilliseconds: 60 * 1000, fetchTimeoutSeconds: 60  } });\n  \n  // If result is empty, exit task with return \n  if(queryTempRecords.result.records === undefined) {\n    console.log('queryTempRecords is empty, nothing to do.');\n    return;\n  }\n  const records = queryTempRecords.result.records;\n \n  var events = [];\n  var timestamp = \"\";\n  const nowMinusTwentyFourH = now - (MS_IN_DAY);\n\n\n  console.log(records);\n  \n  // Loop through each of the records and create the permanent event ready to be sent\n  records.forEach((item) => {  \n\n    var futureTimestamp = new Date(item[\"future.timestamp\"]);\n\n    // If the future timestamp attribute is less than 24 hours ago and less than now, then\n    // continue because the API will take it\n    if(futureTimestamp > nowMinusTwentyFourH && futureTimestamp < now) {\n      console.log(\"Creating event\");\n      \n      // Replace the timestamp with the \"future timestamp\" we gave it and \n      // remove unwanted fields\n      timestamp = item[\"future.timestamp\"];\n      item[\"timestamp\"] = timestamp;\n      item[\"event.provider\"] = item[\"event.provider\"].substring(0, item[\"event.provider\"].length - 5);\n      delete item[\"future.timestamp\"];\n      delete item[\"lookup.timestamp\"];\n      delete item[\"event.id\"];\n      delete item[\"event.kind\"];\n\n      events.push(item);\n    }\n\n    \n  })\n\n  console.log(events);\n  \n  //Send all the new permanent events into the BizEvents API\n  const result = await fetch('/platform/classic/environment-api/v2/bizevents/ingest', {\n    method: 'POST',\n    headers: { 'Content-Type': 'application/json' },\n    body: JSON.stringify(events),\n  });\n\n  console.log(result);\n  \n  return;\n}"
      },
      "active": true,
      "position": {
        "x": 1,
        "y": 2
      },
      "predecessors": [
        "config"
      ],
      "conditions": {
        "states": {
          "config": "OK"
        }
      }
    }
  },
  "description": "",
  "actor": "bb76f07e-5800-412d-a53e-2ef79a89b073",
  "owner": "bb76f07e-5800-412d-a53e-2ef79a89b073",
  "ownerType": "USER",
  "isPrivate": true,
  "trigger": {
    "schedule": {
      "isActive": true,
      "isFaulty": false,
      "trigger": {
        "type": "interval",
        "intervalMinutes": 5
      },
      "rule": null,
      "filterParameters": {
        "earliestStart": "2024-04-24",
        "earliestStartTime": "00:00"
      },
      "timezone": "Europe/London",
      "inputs": {},
      "nextExecution": "2024-11-15T20:30:00.000Z"
    }
  },
  "schemaVersion": 3
}